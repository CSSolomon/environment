# |----------------------------------------------------------------------------|
# |                             Program information                            |
# |----------------------------------------------------------------------------|
# | File     : /etc/bash.bashrc.local                                          |
# | PL       : bash (ARCHLinux OS)                                             |
# | Purpose  : Is sourced by all bash sessions to make useful initialisations. |
# | Course   :                                                                 |
# | Date     : 2012_12_20                                                      |
# | Author   : Seeker_Odysseas                                                 |
# | +          seeker_odysseas@yahoo.co.uk                                     |
# |----------------------------------------------------------------------------|
# | Keywords : bash bashrc custom local                                        |
# |----------------------------------------------------------------------------|

#
# /etc/bash.bashrc
#


# THIS PART DEACTIVATES CERTAIN PARTS IN CASE OF EMERGENCY (MANUAL INTERVENTION)
#export SCREEN_SESSION_ACTIVE=true;

# Run interactively.
[ ! -z "${PS1}" ] && {
      #
    ### -- Initialisations.
    #
    
        # Set up completion.
        [ -r /usr/share/bash-completion/bash_completion ] && \
            . /usr/share/bash-completion/bash_completion;

        # Source locale.conf if present.
        [ -r /etc/locale.conf ] && \
            . <(cat /etc/locale.conf | sed -e "s/^/export /")
            
        # Ensure there's a timeout limit.
            TMOUT=600; readonly TMOUT; export TMOUT;

        # Set history control properly
            export HISTCONTROL="ignoreboth:erasedups";
            export HISTSIZE="1000";
           
        # Activate useful shopt options
            shopt -s checkjobs checkwinsize

        # Make path give priority to local path.
            [[ "${PATH}" =~ "${HOME}/bin" ]] || {
                export PATH="${HOME}/bin:$PATH";
            }

      #
    ### -- Functions
    #

        # Merge the grub configurations for the two systems.
            function custom_grub(){
                echo "#!/bin/sh" > /etc/grub.d/42_custom;
                echo "cat << EOFCUSTOM42" >> /etc/grub.d/42_custom;
                startstop=( $(grep -n -e "10_" /home/suseroot/boot/grub2/grub.cfg | cut -f 1 -d ":" ) ) ; 
                tail -n +${startstop[0]} /home/suseroot/boot/grub2/grub.cfg | head -n +$((1 + startstop[1] - startstop[0])) >> /etc/grub.d/42_custom;
                echo -n "EOFCUSTOM42" >> /etc/grub.d/42_custom;
                chmod +x /etc/grub.d/42_custom;
            }; # Funcion custom_grub
            
        # Get a progressively more alarming history number color, depending on how many are used up.
            function getHistColor(){
                #local histcmd="$( cat ${HOME}/.bash_history 2>/dev/null | wc -l )" ;
                eval local histcmd="$(history | wc -l)";
                if [ -z "${histcmd}" -o 0 -eq "${histcmd}" ] ; then
                    histcmd="1"; 
                fi
                local histColorsList=( 32 34 36 35 33 31 );
                local histColorsListLength="${#histColorsList[@]}";
                local histPercentageChange=$(( HISTSIZE / histColorsListLength ));
                local histPointer="$(( histcmd / histPercentageChange ))";
                local histcolor="${histColorsList[histPointer]}";
                echo -n "${histcolor}"; 
            } ; # getHistColor

      #
    ### -- Variables
    #
        # Set the custom editor to vim.
            export EDITOR="$(which vim)"
            
        # Set PS1 to a more informative view.
            PS1='\[\e[1m\]\u@\h \w\[\e[0;m\] \[\e[3;$(getHistColor)m\]\!\[\e[0;m\]\$ '
            PS2='> '
            PS3='> '
            PS4='+ '
            [ -x "$(which vim)" ] && \
             { 
                export VISUAL=$(which vim) ; export EDITOR=$(which vim) ;
             }
            ps1prefix="\[\e[1;33m\]DT_lvl:\[\e[1;38m\]${SHLVL}";
            ps1prefix="${ps1prefix}\[\e[1;34m\]\D{%Y%m%d}\[\e[0m\]:\[\e[1;37m\]\D{%H%M%S}\[\e[0;m\]"
            PS2="++ "
            if test "$UID" -eq 0 ; then
                PS1="${ps1prefix} \[\e[0;31m\]${PS1} \[\e[0;m\]"
            else
                PS1="${ps1prefix} $PS1"
            fi

        # Aliases.
            lsflags="$lsflags --color"
            alias now='date +%Y%m%d%H%M%S'
            alias rm="/usr/bin/rm -i"
            alias ls="/bin/ls $lsflags"
            alias grep="/usr/bin/grep --color=auto"
            alias init="echo init is deprecated. "
            alias brst="killall -s SIGWINCH -u \$(whoami) bash" ;
            alias less="/usr/bin/less -R";
            alias pacman="/usr/bin/pacman --color=always";
            histclear_prefixes=( \
                    'yaourt' 'cd' 'cp' 'mv' 'rm' 'echo' 'cat' 'ls' 'screen' '#' '[A-Z0-9]' 'u\+mount' \
                    'pacman' 'grep' 'su' 'sudo' 'sschool' 'spersonal' 'ssh' 'scp' 'ping' 'move_to_pane' \
                    'tm m' 'xsel' 'dirname' 'sed' 'eject' 'ethtool' 'for' 'chsh' '[^ ]latex' 'evince' 'clear' \
                    'apropos' 'ip' 'fdisk' 'ftp' 'touch' 'bash' 'kill' 'ps' 'dropbox' \
                    ) ; # histclear_prefixes
            histclear_expr="$(echo -e '^\('$(echo ${histclear_prefixes[*]} | sed -e "s/ /\\\|/g")'\)')";
            alias histclear="history -w; \
                sed -e \"1,200d\" \
                    -e \"/${histclear_expr}/d\" \
                    -i ~/.bash_history; \
                    history -c;
                    history -r;";
            unset histclear_expr histclear_prefixes;

        # Start terminals in screen mode.
            [ "true" = "${SCREEN_SESSION_ACTIVE}" ] || {
               SCREEN_SESSION_ACTIVE="true"; readonly SCREEN_SESSION_ACTIVE; export SCREEN_SESSION_ACTIVE;
                { [ -e /tmp/no_screen ] && rm -f /tmp/no_screen ; } || {
                    screen && 
                    { [ -e /tmp/keep_after_screen ] || exit; } 
                }
            } # SCREEN_SESSION_ACTIVE

      #
    ### -- Run commands on per-group / per user basis 
    #
            case ${GROUPS} in
                   0)
                    lsflags="$lsflags -a"
                    alias ls="/bin/ls $lsflags"
            ;; esac
            
        # Run or create commands and functions on per-user basis. Mostly meaningful in 
        #+ a root / non root mentality.
            case ${UID} in
                   0)
                       # Let the user know if there are files to be commited.
                       { cd /; hg status ; }

                        alias brc="vim /etc/bash.bashrc.local"
                        # Re-makes knockd.conf
                        remake_knockd_conf(){
                            runfile="/etc/knockd.d/knockd.conf.make"
                            output="/etc/knockd.conf"
                            once_seq="/etc/knockd.d/knockd.conf.once"
                            # ${runfile} > ${output}
                            $runfile --tofiles
                            [ -e "${once_seq}" ] && { ${once_seq} >> ${output} ; }
                            systemctl restart knockd;
                            systemctl status --quiet knockd.service || echo 1>&2 "Problem  starting knockd.service";
                        } # remake_knockd_conf
                        
                        # mounts home directory for predefined time-period.
                        timed_mount(){
                             time="${1}";
                             [ ! -z "${time}" ] || \
                                { \
                                    echo -n "Give time: " && \
                                    read -s time ;
                                    echo "" ;
                                }
                             [ ! -z "${time}" ] || return 1 ;
                             [ 0 -lt "${time}" ] 2>/dev/null || return 1;
                             [ -z "$1" ] && \
                             echo "Session will last for ${time} minutes";
                             tm m seek; 
                             su -c "/home/seeker/bin/notify_shutdown.sh --timestamp ${time}" seeker;  
                             { sleep ${time}m && pkill X ; sleep 20s; \
                             xset -display ":0.0" +dpms; \
                             xset -display ":0.0" dpms 10 10 10 ;} &
                        } # timed mount

                        # This function creates a tar archive containing the files customized
                        #+ for my convenience. This is a more convenient base to work with 
                        #+ than the hg archive, whose latest update is useful in getting their
                        #+ latest version.
                        update_root_files_store(){
                            echo "The status of changes is as follows: "
                            changed_files=$( hg status )
                            echo "${changed_files}"
                            changed_files=$( echo "${changed_files}" | sed -e "s/^. //" )
                            [ -z "$changed_files" ] && { echo "No files changed. Exiting."; return 0; }
                            case $# in
                                0)
                                    echo -n "Please provide message to be used with hg commit: " ;
                                    read message;
                                    echo -n "(Optional): Please provide list of files to commit: " ;
                                    read filelist ;
                                ;; # No arguments given.
                                1)
                                    message=${1}
                                    echo -n "(Optional): Please provide list of files to commit: " ;
                                    read filelist ;
                                ;; # Only message given.
                                *)
                                    message="${1}" ;
                                    filelist=( ${@:2} ) ;
                                ;; # Message and filelist given.
                            esac
                            # FIXME This is a clusterfuck. Tidy it up.
                            { cd /; hg commit -m "${message}" ${filelist[@]}; }
                            case $(uname -r) in
                            *-suse)
                                filename="/home/root/opensuse/opensuse.rootfiles.$(date +%Y%m%d%H)" ;
                            ;;
                            *-ARCH | *-lts )
                                filename="/home/root/archlinux/archlinux.rootfiles.$(date +%Y%m%d%H)" ;
                            ;;
                            esac
                            echo -n "Would you like to only store the altered files? (Y/n): " ;
                            exclude_files="$(hg status | grep -e '^[R!]' | sed -e 's/^. //')";
                            read store_only_changed ;
                            echo ${filename} ;
                            [ -e "$( dirname ${filename} )" ] && \
                            [ -e "/.hg/" ] && \
                            { 
                                [ "n" = "${store_only_changed}" ] && \
                                { cd /; tar cjvf ${filename}.full.tz2 $(hg locate | grep -vf <(echo "${exclude_files}" | grep -ve "^$"; echo "DummYNamME") ) ; } ; 
                            } || \
                            {
                                { cd /; tar cjvf ${filename}.incremental.tz2 $( \
                                    echo "${changed_files}" | grep -vf <(echo "${exclude_files}") ) ; } ;
                            }

                        } # update_root_files_store(){}

                        # This function updates the list of the files I have installed after
                        #+ a fresh setup. It proves useful in bringing the OS as close to the
                        #+ last installation stage as possible..
                        update_programlist(){
                            timestamp="$(now)";
                            ( which zypper 1>/dev/null 2>/dev/null ) && {
                                programlist_file="/home/root/opensuse/suse.programlist.${timestamp}.bak";
                                zypper search -i | \
                                   tail -n +6       | \
                                   cut -b 5-42      | \
                                   sort -u > "${programlist_file}";
                            } ; # zypper exists 
                            ( which pacman 1>/dev/null 2>/dev/null ) && {
                                basedir="/home/root/archlinux";
                                basename="archlinux.programlist.${timestamp}";
                                aur_list="${basedir}/${basename}.aur";
                                repo_list="${basedir}/${basename}.repos";
                                pacman -Qqm > "${aur_list}";
                                pacman -Qqs | grep -vf "${aur_list}" > "${repo_list}";
                            } ; # pacman exists
                        } ; # update_programlist(){}
                    ;; *)
                        :
            ;; esac
} ; # Run interactively options.   
#   Shell Variables
#       The following variables are set by the shell:
#
#       BASH   Expands  to the full file name used to invoke this instance
#              of bash.
#       BASHOPTS
#              A colon-separated list of enabled shell options.  Each word
#              in  the  list  is a valid argument for the -s option to the
#              shopt builtin command (see SHELL BUILTIN  COMMANDS  below).
#              The  options appearing in BASHOPTS are those reported as on
#              by shopt.  If this variable is in the environment when bash
#              starts  up,  each  shell option in the list will be enabled
#              before reading any startup files.  This variable  is  read-
#              only.
#       BASHPID
#              Expands  to  the  process  ID  of the current bash process.
#              This differs from $$ under certain circumstances,  such  as
#              subshells that do not require bash to be re-initialized.
#       BASH_ALIASES
#              An  associative  array variable whose members correspond to
#              the internal list of aliases as  maintained  by  the  alias
#              builtin.   Elements added to this array appear in the alias
#              list; unsetting array elements cause aliases to be  removed
#              from the alias list.
#       BASH_ARGC
#              An array variable whose values are the number of parameters
#              in each frame of the current  bash  execution  call  stack.
#              The  number  of parameters to the current subroutine (shell
#              function or script executed with . or source) is at the top
#              of the stack.  When a subroutine is executed, the number of
#              parameters passed is pushed onto BASH_ARGC.  The shell sets
#              BASH_ARGC  only  when  in  extended debugging mode (see the
#              description of the extdebug option  to  the  shopt  builtin
#              below)
#       BASH_ARGV
#              An  array  variable containing all of the parameters in the
#              current bash execution call stack.  The final parameter  of
#              the  last  subroutine  call is at the top of the stack; the
#              first parameter of the initial call is at the bottom.  When
#              a  subroutine  is  executed,  the  parameters  supplied are
#              pushed onto BASH_ARGV.  The shell sets BASH_ARGV only  when
#              in  extended  debugging  mode  (see  the description of the
#              extdebug option to the shopt builtin below)
#       BASH_CMDS
#              An associative array variable whose members  correspond  to
#              the  internal  hash  table of commands as maintained by the
#              hash builtin.  Elements added to this array appear  in  the
#              hash  table;  unsetting array elements cause commands to be
#              removed from the hash table.
#       BASH_COMMAND
#              The command currently being executed or about  to  be  exe‐
#              cuted,  unless  the  shell  is  executing  a command as the
#              result of a trap, in which case it is the command executing
#              at the time of the trap.
#       BASH_EXECUTION_STRING
#              The command argument to the -c invocation option.
#       BASH_LINENO
#              An  array  variable  whose  members are the line numbers in
#              source files where each corresponding  member  of  FUNCNAME
#              was  invoked.  ${BASH_LINENO[$i]} is the line number in the
#              source file  (${BASH_SOURCE[$i+1]})  where  ${FUNCNAME[$i]}
#              was  called  (or  ${BASH_LINENO[$i-1]} if referenced within
#              another shell function).  Use LINENO to obtain the  current
#              line number.
#       BASH_REMATCH
#              An  array  variable  whose  members  are assigned by the =~
#              binary operator to the [[ conditional command.  The element
#              with  index  0  is  the  portion of the string matching the
#              entire regular expression.  The element with index n is the
#              portion of the string matching the nth parenthesized subex‐
#              pression.  This variable is read-only.
#       BASH_SOURCE
#              An array variable whose members are  the  source  filenames
#              where  the  corresponding shell function names in the FUNC‐
#              NAME  array  variable  are  defined.   The  shell  function
#              ${FUNCNAME[$i]}  is  defined in the file ${BASH_SOURCE[$i]}
#              and called from ${BASH_SOURCE[$i+1]}.
#       BASH_SUBSHELL
#              Incremented by one each time a subshell or  subshell  envi‐
#              ronment is spawned.  The initial value is 0.
#       BASH_VERSINFO
#              A readonly array variable whose members hold version infor‐
#              mation for this instance of bash.  The values  assigned  to
#              the array members are as follows:
#              BASH_VERSINFO[0]        The   major   version  number  (the
#                                      release).
#              BASH_VERSINFO[1]        The minor version number (the  ver‐
#                                      sion).
#              BASH_VERSINFO[2]        The patch level.
#              BASH_VERSINFO[3]        The build version.
#              BASH_VERSINFO[4]        The release status (e.g., beta1).
#              BASH_VERSINFO[5]        The value of MACHTYPE.
#       BASH_VERSION
#              Expands to a string describing the version of this instance
#              of bash.
#       COMP_CWORD
#              An index into ${COMP_WORDS} of the word containing the cur‐
#              rent  cursor  position.  This variable is available only in
#              shell functions  invoked  by  the  programmable  completion
#              facilities (see Programmable Completion below).
#       COMP_KEY
#              The key (or final key of a key sequence) used to invoke the
#              current completion function.
#       COMP_LINE
#              The current command line.  This variable is available  only
#              in  shell  functions  and  external commands invoked by the
#              programmable completion facilities (see  Programmable  Com‐
#              pletion below).
#       COMP_POINT
#              The  index  of  the current cursor position relative to the
#              beginning of the current command.  If  the  current  cursor
#              position is at the end of the current command, the value of
#              this variable is equal to ${#COMP_LINE}.  This variable  is
#              available  only  in  shell  functions and external commands
#              invoked by the programmable completion facilities (see Pro‐
#              grammable Completion below).
#       COMP_TYPE
#              Set  to  an integer value corresponding to the type of com‐
#              pletion attempted that caused a completion function  to  be
#              called:  TAB, for normal completion, ?, for listing comple‐
#              tions after successive tabs, !, for listing alternatives on
#              partial word completion, @, to list completions if the word
#              is not unmodified, or %, for menu completion.   This  vari‐
#              able is available only in shell functions and external com‐
#              mands invoked by  the  programmable  completion  facilities
#              (see Programmable Completion below).
#       COMP_WORDBREAKS
#              The  set  of characters that the readline library treats as
#              word  separators  when  performing  word  completion.    If
#              COMP_WORDBREAKS  is unset, it loses its special properties,
#              even if it is subsequently reset.
#       COMP_WORDS
#              An array variable (see  Arrays  below)  consisting  of  the
#              individual  words in the current command line.  The line is
#              split  into  words  as  readline  would  split  it,   using
#              COMP_WORDBREAKS  as  described  above.   This  variable  is
#              available only in shell functions invoked by  the  program‐
#              mable  completion  facilities  (see Programmable Completion
#              below).
#       COPROC An array variable (see Arrays below) created  to  hold  the
#              file  descriptors  for  output from and input to an unnamed
#              coprocess (see Coprocesses above).
#       DIRSTACK
#              An array variable (see Arrays below) containing the current
#              contents of the directory stack.  Directories appear in the
#              stack in the order they are displayed by the dirs  builtin.
#              Assigning  to members of this array variable may be used to
#              modify directories already in the stack, but the pushd  and
#              popd  builtins  must be used to add and remove directories.
#              Assignment to this variable will  not  change  the  current
#              directory.   If  DIRSTACK  is  unset,  it loses its special
#              properties, even if it is subsequently reset.
#       EUID   Expands to the effective user ID of the current user,  ini‐
#              tialized at shell startup.  This variable is readonly.
#       FUNCNAME
#              An  array  variable containing the names of all shell func‐
#              tions currently in the execution call stack.   The  element
#              with  index  0 is the name of any currently-executing shell
#              function.  The bottom-most element (the one with the  high‐
#              est  index)  is  "main".   This variable exists only when a
#              shell function is executing.  Assignments to FUNCNAME  have
#              no  effect  and  return  an  error  status.  If FUNCNAME is
#              unset, it loses its special properties, even if it is  sub‐
#              sequently reset.
#
#              This variable can be used with BASH_LINENO and BASH_SOURCE.
#              Each element of  FUNCNAME  has  corresponding  elements  in
#              BASH_LINENO  and  BASH_SOURCE  to  describe the call stack.
#              For instance, ${FUNCNAME[$i]}  was  called  from  the  file
#              ${BASH_SOURCE[$i+1]}  at  line  number  ${BASH_LINENO[$i]}.
#              The caller builtin displays the current  call  stack  using
#              this information.
#       GROUPS An  array  variable  containing the list of groups of which
#              the current user is a member.  Assignments to  GROUPS  have
#              no  effect and return an error status.  If GROUPS is unset,
#              it loses its special properties, even if it is subsequently
#              reset.
#       HISTCMD
#              The  history  number,  or index in the history list, of the
#              current command.  If HISTCMD is unset, it loses its special
#              properties, even if it is subsequently reset.
#       HOSTNAME
#              Automatically set to the name of the current host.
#       HOSTTYPE
#              Automatically  set  to a string that uniquely describes the
#              type of machine on which bash is executing.  The default is
#              system-dependent.
#       LINENO Each  time  this parameter is referenced, the shell substi‐
#              tutes a decimal number representing the current  sequential
#              line  number (starting with 1) within a script or function.
#              When not in a script or function, the value substituted  is
#              not  guaranteed  to  be meaningful.  If LINENO is unset, it
#              loses its special properties, even if  it  is  subsequently
#              reset.
#       MACHTYPE
#              Automatically set to a string that fully describes the sys‐
#              tem type on which bash is executing, in  the  standard  GNU
#              cpu-company-system  format.   The  default is system-depen‐
#              dent.
#       MAPFILE
#              An array variable (see Arrays below) created  to  hold  the
#              text  read  by the mapfile builtin when no variable name is
#              supplied.
#       OLDPWD The previous working directory as set by the cd command.
#       OPTARG The value of the last  option  argument  processed  by  the
#              getopts builtin command (see SHELL BUILTIN COMMANDS below).
#       OPTIND The  index  of  the  next  argument  to be processed by the
#              getopts builtin command (see SHELL BUILTIN COMMANDS below).
#       OSTYPE Automatically set to a string that describes the  operating
#              system  on which bash is executing.  The default is system-
#              dependent.
#       PIPESTATUS
#              An array variable (see Arrays below) containing a  list  of
#              exit status values from the processes in the most-recently-
#              executed foreground pipeline (which may contain only a sin‐
#              gle command).
#       PPID   The  process  ID  of  the shell's parent.  This variable is
#              readonly.
#       PWD    The current working directory as set by the cd command.
#       RANDOM Each time this parameter is referenced,  a  random  integer
#              between  0  and 32767 is generated.  The sequence of random
#              numbers may be initialized by assigning a value to  RANDOM.
#              If  RANDOM  is unset, it loses its special properties, even
#              if it is subsequently reset.
#       READLINE_LINE
#              The contents of the readline  line  buffer,  for  use  with
#              "bind -x" (see SHELL BUILTIN COMMANDS below).
#       READLINE_POINT
#              The  position  of  the insertion point in the readline line
#              buffer, for use with "bind -x" (see SHELL BUILTIN  COMMANDS
#              below).
#       REPLY  Set  to  the line of input read by the read builtin command
#              when no arguments are supplied.
#       SECONDS
#              Each time this parameter is referenced, the number of  sec‐
#              onds  since  shell  invocation  is returned.  If a value is
#              assigned to SECONDS, the  value  returned  upon  subsequent
#              references  is  the  number of seconds since the assignment
#              plus the value assigned.  If SECONDS is unset, it loses its
#              special properties, even if it is subsequently reset.
#       SHELLOPTS
#              A colon-separated list of enabled shell options.  Each word
#              in the list is a valid argument for the -o  option  to  the
#              set  builtin  command  (see  SHELL BUILTIN COMMANDS below).
#              The options appearing in SHELLOPTS are those reported as on
#              by  set  -o.   If  this variable is in the environment when
#              bash starts up, each shell  option  in  the  list  will  be
#              enabled before reading any startup files.  This variable is
#              read-only.
#       SHLVL  Incremented by  one  each  time  an  instance  of  bash  is
#              started.
#       UID    Expands  to the user ID of the current user, initialized at
#              shell startup.  This variable is readonly.
#
#       The following variables are used by the  shell.   In  some  cases,
#       bash  assigns a default value to a variable; these cases are noted
#       below.
#
#       BASH_ENV
#              If this parameter is set when bash  is  executing  a  shell
#              script,  its  value is interpreted as a filename containing
#              commands to initialize the shell,  as  in  ~/.bashrc.   The
#              value of BASH_ENV is subjected to parameter expansion, com‐
#              mand substitution, and arithmetic  expansion  before  being
#              interpreted as a file name.  PATH is not used to search for
#              the resultant file name.
#       BASH_XTRACEFD
#              If set to an integer corresponding to a valid file descrip‐
#              tor, bash will write the trace output generated when set -x
#              is enabled to that file descriptor.  The file descriptor is
#              closed when BASH_XTRACEFD is unset or assigned a new value.
#              Unsetting BASH_XTRACEFD or assigning it  the  empty  string
#              causes  the  trace output to be sent to the standard error.
#              Note that setting BASH_XTRACEFD to 2  (the  standard  error
#              file  descriptor)  and then unsetting it will result in the
#              standard error being closed.
#       CDPATH The search path for the cd command.  This is a  colon-sepa‐
#              rated list of directories in which the shell looks for des‐
#              tination directories specified by the cd command.  A sample
#              value is ".:~:/usr".
#       COLUMNS
#              Used by the select compound command to determine the termi‐
#              nal width when printing selection lists.  Automatically set
#              upon receipt of a SIGWINCH.
#       COMPREPLY
#              An  array  variable from which bash reads the possible com‐
#              pletions generated by a shell function invoked by the  pro‐
#              grammable  completion facility (see Programmable Completion
#              below).
#       EMACS  If bash finds this variable in  the  environment  when  the
#              shell  starts  with value "t", it assumes that the shell is
#              running in an Emacs shell buffer and disables line editing.
#       ENV    Similar to BASH_ENV; used when  the  shell  is  invoked  in
#              POSIX mode.
#       FCEDIT The default editor for the fc builtin command.
#       FIGNORE
#              A  colon-separated list of suffixes to ignore when perform‐
#              ing filename completion (see READLINE below).   A  filename
#              whose  suffix  matches  one  of  the  entries in FIGNORE is
#              excluded from the list  of  matched  filenames.   A  sample
#              value is ".o:~".
#       FUNCNEST
#              If set to a numeric value greater than 0, defines a maximum
#              function nesting level.  Function invocations  that  exceed
#              this nesting level will cause the current command to abort.
#       GLOBIGNORE
#              A  colon-separated  list  of  patterns  defining the set of
#              filenames to be ignored by pathname expansion.  If a  file‐
#              name  matched  by a pathname expansion pattern also matches
#              one of the patterns in GLOBIGNORE, it is removed  from  the
#              list of matches.
#       HISTCONTROL
#              A  colon-separated  list of values controlling how commands
#              are saved on the history  list.   If  the  list  of  values
#              includes  ignorespace, lines which begin with a space char‐
#              acter are not saved  in  the  history  list.   A  value  of
#              ignoredups causes lines matching the previous history entry
#              to not be saved.  A value of ignoreboth  is  shorthand  for
#              ignorespace  and  ignoredups.   A value of erasedups causes
#              all previous lines matching the current line to be  removed
#              from the history list before that line is saved.  Any value
#              not in the above list is ignored.  If HISTCONTROL is unset,
#              or  does  not  include a valid value, all lines read by the
#              shell parser are saved on the history list, subject to  the
#              value  of HISTIGNORE.  The second and subsequent lines of a
#              multi-line compound command are not tested, and  are  added
#              to the history regardless of the value of HISTCONTROL.
#       HISTFILE
#              The name of the file in which command history is saved (see
#              HISTORY below).  The default value is ~/.bash_history.   If
#              unset, the command history is not saved when an interactive
#              shell exits.
#       HISTFILESIZE
#              The maximum number of lines contained in the history  file.
#              When this variable is assigned a value, the history file is
#              truncated, if necessary, by removing the oldest entries, to
#              contain  no  more  than  that number of lines.  The default
#              value is 500.  The history file is also truncated  to  this
#              size after writing it when an interactive shell exits.
#       HISTIGNORE
#              A  colon-separated  list  of  patterns used to decide which
#              command lines should be saved on the  history  list.   Each
#              pattern  is  anchored at the beginning of the line and must
#              match the complete line  (no  implicit  `*'  is  appended).
#              Each  pattern  is  tested against the line after the checks
#              specified by HISTCONTROL are applied.  In addition  to  the
#              normal  shell  pattern matching characters, `&' matches the
#              previous history line.  `&' may be escaped  using  a  back‐
#              slash;  the backslash is removed before attempting a match.
#              The second and subsequent lines of  a  multi-line  compound
#              command  are  not  tested,  and  are  added  to the history
#              regardless of the value of HISTIGNORE.
#       HISTSIZE
#              The number of commands to remember in the  command  history
#              (see HISTORY below).  The default value is 500.
#       HISTTIMEFORMAT
#              If  this variable is set and not null, its value is used as
#              a format string for strftime(3) to  print  the  time  stamp
#              associated with each history entry displayed by the history
#              builtin.  If this variable is set, time stamps are  written
#              to  the  history file so they may be preserved across shell
#              sessions.  This uses the history comment character to  dis‐
#              tinguish timestamps from other history lines.
#       HOME   The  home  directory of the current user; the default argu‐
#              ment for the cd builtin command.  The value of  this  vari‐
#              able is also used when performing tilde expansion.
#       HOSTFILE
#              Contains  the  name  of  a  file  in  the  same  format  as
#              /etc/hosts that should be read when the shell needs to com‐
#              plete  a  hostname.   The list of possible hostname comple‐
#              tions may be changed while the shell is running;  the  next
#              time  hostname  completion  is attempted after the value is
#              changed, bash adds the contents of  the  new  file  to  the
#              existing  list.   If  HOSTFILE is set, but has no value, or
#              does not name  a  readable  file,  bash  attempts  to  read
#              /etc/hosts  to obtain the list of possible hostname comple‐
#              tions.  When  HOSTFILE  is  unset,  the  hostname  list  is
#              cleared.
#       IFS    The  Internal  Field Separator that is used for word split‐
#              ting after expansion and to split lines into words with the
#              read    builtin    command.     The    default   value   is
#              ``<space><tab><newline>''.
#       IGNOREEOF
#              Controls the action of an interactive shell on  receipt  of
#              an  EOF  character as the sole input.  If set, the value is
#              the number of consecutive  EOF  characters  which  must  be
#              typed  as the first characters on an input line before bash
#              exits.  If the variable exists but does not have a  numeric
#              value,  or  has  no  value, the default value is 10.  If it
#              does not exist, EOF signifies  the  end  of  input  to  the
#              shell.
#       INPUTRC
#              The  filename for the readline startup file, overriding the
#              default of ~/.inputrc (see READLINE below).
#       LANG   Used to determine the locale category for any category  not
#              specifically selected with a variable starting with LC_.
#       LC_ALL This variable overrides the value of LANG and any other LC_
#              variable specifying a locale category.
#       LC_COLLATE
#              This variable determines  the  collation  order  used  when
#              sorting  the  results of pathname expansion, and determines
#              the behavior of range expressions, equivalence classes, and
#              collating  sequences  within pathname expansion and pattern
#              matching.
#       LC_CTYPE
#              This variable determines the interpretation  of  characters
#              and  the  behavior  of  character  classes  within pathname
#              expansion and pattern matching.
#       LC_MESSAGES
#              This variable determines the locale used to translate  dou‐
#              ble-quoted strings preceded by a $.
#       LC_NUMERIC
#              This  variable determines the locale category used for num‐
#              ber formatting.
#       LINES  Used by the select compound command to determine the column
#              length  for  printing  selection  lists.  Automatically set
#              upon receipt of a SIGWINCH.
#       MAIL   If this parameter is set to a file or  directory  name  and
#              the  MAILPATH variable is not set, bash informs the user of
#              the arrival of mail in the specified file or Maildir-format
#              directory.
#       MAILCHECK
#              Specifies how often (in seconds) bash checks for mail.  The
#              default is 60 seconds.  When it is time to check for  mail,
#              the shell does so before displaying the primary prompt.  If
#              this variable is unset, or set to a value  that  is  not  a
#              number  greater  than  or equal to zero, the shell disables
#              mail checking.
#       MAILPATH
#              A colon-separated list of file  names  to  be  checked  for
#              mail.   The  message  to  be printed when mail arrives in a
#              particular file may be specified  by  separating  the  file
#              name from the message with a `?'.  When used in the text of
#              the message, $_ expands to the name of  the  current  mail‐
#              file.  Example:
#              MAILPATH='/var/mail/bfox?"You  have  mail":~/shell-mail?"$_
#              has mail!"'
#              Bash supplies a default value for this  variable,  but  the
#              location  of  the  user  mail  files that it uses is system
#              dependent (e.g., /var/mail/$USER).
#       OPTERR If set to the value 1, bash displays error messages  gener‐
#              ated by the getopts builtin command (see SHELL BUILTIN COM‐
#              MANDS below).  OPTERR is initialized to  1  each  time  the
#              shell is invoked or a shell script is executed.
#       PATH   The search path for commands.  It is a colon-separated list
#              of directories in which the shell looks for  commands  (see
#              COMMAND  EXECUTION  below).  A zero-length (null) directory
#              name in the value of PATH indicates the current  directory.
#              A null directory name may appear as two adjacent colons, or
#              as an initial or trailing colon.  The default path is  sys‐
#              tem-dependent, and is set by the administrator who installs
#              bash.          A          common          value          is
#              ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
#       POSIXLY_CORRECT
#              If  this  variable  is in the environment when bash starts,
#              the shell enters posix  mode  before  reading  the  startup
#              files,  as  if  the --posix invocation option had been sup‐
#              plied.  If it is set  while  the  shell  is  running,  bash
#              enables posix mode, as if the command set -o posix had been
#              executed.
#       PROMPT_COMMAND
#              If set, the value is executed as a command prior to issuing
#              each primary prompt.
#       PROMPT_DIRTRIM
#              If  set to a number greater than zero, the value is used as
#              the number of trailing directory components to retain  when
#              expanding  the \w and \W prompt string escapes (see PROMPT‐
#              ING below).  Characters removed are replaced with an ellip‐
#              sis.
#       PS1    The  value  of  this  parameter  is expanded (see PROMPTING
#              below) and used as the primary prompt string.  The  default
#              value is ``\s-\v\$ ''.
#       PS2    The  value  of  this  parameter is expanded as with PS1 and
#              used as the secondary prompt string.  The  default  is  ``>
#              ''.
#       PS3    The  value  of this parameter is used as the prompt for the
#              select command (see SHELL GRAMMAR above).
#       PS4    The value of this parameter is expanded as with PS1 and the
#              value  is  printed before each command bash displays during
#              an execution trace.  The first character of PS4  is  repli‐
#              cated  multiple  times,  as necessary, to indicate multiple
#              levels of indirection.  The default is ``+ ''.
#       SHELL  The full pathname to the shell is kept in this  environment
#              variable.   If  it  is  not set when the shell starts, bash
#              assigns to it the full pathname of the current user's login
#              shell.
#       TIMEFORMAT
#              The  value  of  this  parameter  is used as a format string
#              specifying how the timing information  for  pipelines  pre‐
#              fixed with the time reserved word should be displayed.  The
#              % character introduces an escape sequence that is  expanded
#              to a time value or other information.  The escape sequences
#              and their  meanings  are  as  follows;  the  braces  denote
#              optional portions.
#              %%        A literal %.
#              %[p][l]R  The elapsed time in seconds.
#              %[p][l]U  The number of CPU seconds spent in user mode.
#              %[p][l]S  The number of CPU seconds spent in system mode.
#              %P        The CPU percentage, computed as (%U + %S) / %R.
#
#              The  optional  p  is  a digit specifying the precision, the
#              number of fractional digits after a decimal point.  A value
#              of  0 causes no decimal point or fraction to be output.  At
#              most three places after the decimal point may be specified;
#              values  of  p greater than 3 are changed to 3.  If p is not
#              specified, the value 3 is used.
#
#              The optional l specifies a longer  format,  including  min‐
#              utes,  of  the  form  MMmSS.FFs.  The value of p determines
#              whether or not the fraction is included.
#
#              If this variable is not set, bash acts as  if  it  had  the
#              value  $'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'.   If the value
#              is null, no timing information is  displayed.   A  trailing
#              newline is added when the format string is displayed.
#       TMOUT  If  set  to  a value greater than zero, TMOUT is treated as
#              the default timeout for the read builtin.  The select  com‐
#              mand  terminates  if input does not arrive after TMOUT sec‐
#              onds when input is coming from a terminal.  In an  interac‐
#              tive  shell, the value is interpreted as the number of sec‐
#              onds to wait for input after issuing  the  primary  prompt.
#              Bash terminates after waiting for that number of seconds if
#              input does not arrive.
#       TMPDIR If set, bash uses its value as the name of a  directory  in
#              which bash creates temporary files for the shell's use.
#       auto_resume
#              This  variable  controls  how  the shell interacts with the
#              user and job control.  If this variable is set, single word
#              simple  commands without redirections are treated as candi‐
#              dates for resumption of an existing stopped job.  There  is
#              no  ambiguity allowed; if there is more than one job begin‐
#              ning with the string typed, the job most recently  accessed
#              is  selected.   The name of a stopped job, in this context,
#              is the command line used to start it.  If set to the  value
#              exact, the string supplied must match the name of a stopped
#              job exactly; if set to substring, the string supplied needs
#              to  match  a  substring  of the name of a stopped job.  The
#              substring value provides functionality analogous to the  %?
#              job  identifier  (see  JOB  CONTROL  below).  If set to any
#              other value, the supplied string must  be  a  prefix  of  a
#              stopped  job's  name; this provides functionality analogous
#              to the %string job identifier.
#       histchars
#              The two or three characters which control history expansion
#              and  tokenization (see HISTORY EXPANSION below).  The first
#              character is the history expansion character, the character
#              which  signals  the  start of a history expansion, normally
#              `!'.  The second character is the quick substitution  char‐
#              acter, which is used as shorthand for re-running the previ‐
#              ous command entered, substituting one string for another in
#              the command.  The default is `^'.  The optional third char‐
#              acter is the character which indicates that  the  remainder
#              of  the line is a comment when found as the first character
#              of a word, normally `#'.   The  history  comment  character
#              causes history substitution to be skipped for the remaining
#              words on the line.  It does not necessarily cause the shell
#              parser to treat the rest of the line as a comment.
